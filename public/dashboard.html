<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SOLANA SNIPER BOT - WTF Dashboard</title>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'JetBrains Mono', monospace;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(90deg, #1a1a1a, #2a2a2a);
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #00ff88;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.1), transparent);
            animation: scan 3s infinite;
        }

        @keyframes scan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 700;
            color: #00ff88;
            text-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
            letter-spacing: 2px;
        }

        .wtf-badge {
            background: linear-gradient(45deg, #ff0066, #ff6600);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255, 0, 102, 0.5);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .container {
            padding: 2rem;
            max-width: 1600px;
            margin: 0 auto;
        }

        .danger-warning {
            background: linear-gradient(45deg, #ff0066, #ff3300);
            border: 2px solid #ff6600;
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            text-align: center;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(255, 0, 102, 0.3);
        }

        .danger-warning::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: rotate 4s linear infinite;
        }

        @keyframes rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .danger-warning h2 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
        }

        /* ACTIVE POSITIONS - MAIN FEATURE */
        .positions-hero {
            margin-bottom: 3rem;
        }

        .positions-hero h2 {
            font-size: 2.5rem;
            color: #00ff88;
            text-align: center;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            letter-spacing: 3px;
        }

        .positions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .position-card {
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            border: 2px solid #00ff88;
            border-radius: 20px;
            padding: 2rem;
            position: relative;
            overflow: hidden;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.2);
            transition: all 0.3s ease;
        }

        .position-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 40px rgba(0, 255, 136, 0.4);
        }

        .position-card::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ff88, #0088ff, #ff0066, #ff6600);
            z-index: -1;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .position-card:hover::before {
            opacity: 0.3;
        }

        .position-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .position-token {
            font-size: 1.8rem;
            font-weight: 700;
            color: #ffffff;
        }

        .position-status {
            padding: 0.5rem 1rem;
            border-radius: 15px;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-active {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .status-closed {
            background: linear-gradient(45deg, #666, #888);
            color: #fff;
        }

        .status-profitable {
            background: linear-gradient(45deg, #00ff88, #00cc66);
            color: #000;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .status-loss {
            background: linear-gradient(45deg, #ff0066, #cc0044);
            color: #fff;
            box-shadow: 0 0 15px rgba(255, 0, 102, 0.5);
        }

        .position-roi {
            font-size: 3rem;
            font-weight: 700;
            text-align: center;
            margin: 1rem 0;
            text-shadow: 0 0 20px currentColor;
        }

        .position-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .position-stat {
            text-align: center;
            padding: 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .position-stat-label {
            font-size: 0.8rem;
            color: #cccccc;
            margin-bottom: 0.5rem;
        }

        .position-stat-value {
            font-size: 1.2rem;
            font-weight: 600;
            color: #ffffff;
        }

        .no-positions {
            text-align: center;
            padding: 4rem;
            font-size: 1.5rem;
            color: #666;
            border: 2px dashed #333;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.02);
        }

        /* MAIN DASHBOARD LAYOUT - 3 COLUMNS */
        .dashboard-layout {
            display: grid;
            grid-template-columns: 250px 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        /* LEFT SIDEBAR - MINI INFO */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .mini-info-card {
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            border: 1px solid #333;
            border-radius: 15px;
            padding: 1rem;
            text-align: center;
        }

        .mini-info-card h4 {
            color: #00ff88;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .mini-info-value {
            font-size: 1.4rem;
            font-weight: 700;
            margin-bottom: 0.25rem;
        }

        .mini-info-subtitle {
            font-size: 0.7rem;
            color: #999;
        }

        /* MIDDLE COLUMN - MAIN CONTENT */
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        /* RIGHT COLUMN - SECONDARY CONTENT */
        .side-content {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }

        .content-card {
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            border: 1px solid #333;
            border-radius: 15px;
            padding: 1.5rem;
            overflow: hidden;
        }

        .content-card h3 {
            color: #00ff88;
            margin-bottom: 1rem;
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .content-card.large {
            min-height: 400px;
        }

        .content-card.medium {
            min-height: 300px;
        }

        .content-card.small {
            min-height: 200px;
        }

        /* KPI CHARTS */
        .kpi-chart-container {
            position: relative;
            height: 250px;
            margin-top: 1rem;
        }

        .chart-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .chart-tab {
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #333;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .chart-tab:hover {
            background: rgba(0, 255, 136, 0.1);
            border-color: #00ff88;
        }

        .chart-tab.active {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
            color: #00ff88;
        }

        /* TRACKED TOKENS TABLE */
        .tracked-tokens-table {
            max-height: 300px;
            overflow-y: auto;
        }

        .tracked-tokens-table table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .tracked-tokens-table th,
        .tracked-tokens-table td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tracked-tokens-table th {
            background: rgba(255, 255, 255, 0.05);
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .token-status {
            padding: 0.25rem 0.5rem;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-tracking {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }

        .status-detected {
            background: rgba(0, 136, 255, 0.2);
            color: #0088ff;
        }

        .status-migrated {
            background: rgba(255, 102, 0, 0.2);
            color: #ff6600;
        }

        .status-failed {
            background: rgba(255, 0, 102, 0.2);
            color: #ff0066;
        }

        /* RESPONSIVE DESIGN */
        @media (max-width: 1200px) {
            .dashboard-layout {
                grid-template-columns: 1fr 1fr;
            }
            
            .sidebar {
                grid-column: 1 / -1;
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                gap: 1rem;
            }
        }

        @media (max-width: 768px) {
            .dashboard-layout {
                grid-template-columns: 1fr;
            }
            
            .sidebar {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
                gap: 1rem;
            }
        }

        .trade-feed {
            max-height: 300px;
            overflow-y: auto;
        }

        .trade-item {
            padding: 1rem;
            margin: 0.5rem 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            border-left: 4px solid;
            transition: all 0.3s ease;
        }

        .trade-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .trade-buy { border-left-color: #00ff88; }
        .trade-sell { border-left-color: #ff0066; }

        .positive { color: #00ff88; }
        .negative { color: #ff0066; }
        .neutral { color: #0088ff; }

        .footer {
            text-align: center;
            padding: 2rem;
            background: linear-gradient(90deg, #1a1a1a, #2a2a2a);
            margin-top: 3rem;
            font-size: 0.9rem;
            color: #666;
            border-top: 1px solid #333;
        }

        .footer-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 2rem;
            margin-bottom: 1rem;
            text-align: left;
        }

        .footer-section h4 {
            color: #00ff88;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
        }

        .footer-section p {
            margin: 0.25rem 0;
            font-size: 0.8rem;
        }

        /* ANIMATIONS */
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.2); }
            50% { box-shadow: 0 0 30px rgba(0, 255, 136, 0.4); }
        }

        .glowing {
            animation: glow 2s infinite;
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            .positions-grid {
                grid-template-columns: 1fr;
            }
            
            .secondary-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>sync ?SOLANA SNIPER BOT</h1>
        <div>
            <span class="wtf-badge">DRY RUN</span>
            <span id="connectionStatus" style="margin-left: 1rem;">üî¥ CONNECTING...</span>
        </div>
    </div>

    <div class="container">
        <div class="danger-warning">
            <h2>‚ö†Ô∏è EDUCATIONAL SIMULATION MODE ‚ö†Ô∏è</h2>
            <p>This dashboard shows simulated trading using REAL market data. No real trades are executed.</p>
            <p><small>üîó Live prices ‚Ä¢ üìä Real liquidity ‚Ä¢ üìà Actual market movements ‚Ä¢ üéì Educational purposes only</small></p>
        </div>

        <!-- 3-COLUMN DASHBOARD LAYOUT -->
        <div class="dashboard-layout">
            <!-- LEFT SIDEBAR - MINI INFO -->
            <div class="sidebar">
                <div class="mini-info-card">
                    <h4>Portfolio Value</h4>
                    <div class="mini-info-value neutral" id="totalValue">10.00 SOL</div>
                    <div class="mini-info-subtitle" id="totalValueEur">‚Ç¨1,477.90</div>
                </div>
                
                <div class="mini-info-card">
                    <h4>Total ROI</h4>
                    <div class="mini-info-value neutral" id="totalROI">0.0%</div>
                    <div class="mini-info-subtitle">Overall Performance</div>
                </div>
                
                <div class="mini-info-card">
                    <h4>Win Rate</h4>
                    <div class="mini-info-value neutral" id="winRate">0%</div>
                    <div class="mini-info-subtitle" id="winRateDetail">0/0 trades</div>
                </div>
                
                <div class="mini-info-card">
                    <h4>Active Positions</h4>
                    <div class="mini-info-value neutral" id="activePositions">0</div>
                    <div class="mini-info-subtitle">Current Holdings</div>
                </div>
                
                <div class="mini-info-card">
                    <h4>Available Balance</h4>
                    <div class="mini-info-value neutral" id="availableBalance">10.00 SOL</div>
                    <div class="mini-info-subtitle" id="availableBalanceEur">‚Ç¨1,477.90</div>
                </div>
                
                <div class="mini-info-card">
                    <h4>Token Discovery</h4>
                    <div class="mini-info-value positive" id="tokensFound">0</div>
                    <div class="mini-info-subtitle">Tokens Found</div>
                </div>
                
                <div class="mini-info-card">
                    <h4>Token Analysis</h4>
                    <div class="mini-info-value neutral" id="tokensAnalyzed">0</div>
                    <div class="mini-info-subtitle">Tokens Analyzed</div>
                </div>
                
                <div class="mini-info-card">
                    <h4>Tracked Tokens</h4>
                    <div class="mini-info-value neutral" id="trackedTokens">0</div>
                    <div class="mini-info-subtitle">Price Tracking</div>
                </div>
            </div>

            <!-- MIDDLE COLUMN - MAIN CONTENT -->
            <div class="main-content">
                <!-- KPI CHARTS -->
                <div class="content-card large">
                    <h3>üìà Live KPI Dashboard</h3>
                    <div class="chart-tabs">
                        <div class="chart-tab active" data-chart="portfolio">Portfolio</div>
                        <div class="chart-tab" data-chart="detection">Detection</div>
                        <div class="chart-tab" data-chart="trading">Trading</div>
                        <div class="chart-tab" data-chart="liquidity">Liquidity</div>
                    </div>
                    <div class="kpi-chart-container">
                        <canvas id="kpiChart"></canvas>
                    </div>
                </div>

                <!-- TRACKED TOKENS -->
                <div class="content-card medium">
                    <h3>üîç Tracked Tokens</h3>
                    <div class="tracked-tokens-table">
                        <table id="trackedTokensTable">
                            <thead>
                                <tr>
                                    <th>Symbol</th>
                                    <th>Price</th>
                                    <th>24h Change</th>
                                    <th>Volume</th>
                                    <th>Liquidity</th>
                                    <th>Status</th>
                                    <th>Age</th>
                                    <th>DEX</th>
                                    <th>Bought</th>
                                    <th>Sold</th>
                                    <th>ROI</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div id="noTrackedTokens" style="text-align: center; padding: 2rem; color: #666;">
                            No tokens being tracked yet...
                        </div>
                    </div>
                </div>
            </div>

            <!-- RIGHT COLUMN - SECONDARY CONTENT -->
            <div class="side-content">
                <!-- RECENT TRADES -->
                <div class="content-card medium">
                    <h3>üîÑ Recent Trades</h3>
                    <div class="trade-feed" id="tradeFeed">
                        <div style="text-align: center; padding: 2rem; color: #666;">
                            Waiting for simulated trades...
                        </div>
                    </div>
                </div>
                
                <!-- RECENT FOUND TOKENS -->
                <div class="content-card medium">
                    <h3>üìã Recent Found Tokens</h3>
                    <div style="max-height: 300px; overflow-y: auto;">
                        <table id="foundTokensTable" style="width: 100%; font-size: 0.9rem;">
                            <thead>
                                <tr style="background: rgba(255,255,255,0.1);">
                                    <th style="padding: 0.5rem; text-align: left;">Symbol</th>
                                    <th style="padding: 0.5rem; text-align: right;">Price</th>
                                    <th style="padding: 0.5rem; text-align: right;">Security</th>
                                    <th style="padding: 0.5rem; text-align: right;">Liquidity</th>
                                    <th style="padding: 0.5rem; text-align: right;">Age</th>
                                    <th style="padding: 0.5rem; text-align: center;">DEX</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div id="noFoundTokens" style="text-align: center; padding: 2rem; color: #666;">
                            No tokens found yet...
                        </div>
                    </div>
                </div>
                
                <!-- ANALYZED TOKENS -->
                <div class="content-card medium">
                    <h3>üéØ Analyzed Tokens</h3>
                    <div style="max-height: 300px; overflow-y: auto;">
                        <table id="analyzedTokensTable" style="width: 100%; font-size: 0.9rem;">
                            <thead>
                                <tr style="background: rgba(255,255,255,0.1);">
                                    <th style="padding: 0.5rem; text-align: left;">Symbol</th>
                                    <th style="padding: 0.5rem; text-align: right;">Price</th>
                                    <th style="padding: 0.5rem; text-align: right;">Score</th>
                                    <th style="padding: 0.5rem; text-align: center;">Action</th>
                                    <th style="padding: 0.5rem; text-align: right;">Age</th>
                                </tr>
                            </thead>
                            <tbody></tbody>
                        </table>
                        <div id="noAnalyzedTokens" style="text-align: center; padding: 2rem; color: #666;">
                            No tokens analyzed yet...
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ACTIVE POSITIONS - MOVED BELOW MAIN DASHBOARD -->
        <div class="positions-hero">
            <h2>ACTIVE POSITIONS</h2>
            <div class="positions-grid" id="positionsGrid">
                <div class="no-positions" id="noPositions">
                    NO ACTIVE POSITIONS<br>
                    <small>Waiting for simulated trades...</small>
                </div>
            </div>
        </div>
    </div>

    <div class="footer">
        <div class="footer-info">
            <div class="footer-section">
                <h4>üéì Educational Mode</h4>
                <p>Mode: <span class="positive">DRY RUN</span></p>
                <p>Status: <span class="positive">SIMULATION ACTIVE</span></p>
                <p>Real Trading: <span class="negative">DISABLED</span></p>
                <p>Last Update: <span id="lastUpdate">-</span></p>
            </div>
            
            <div class="footer-section">
                <h4>üìä System Status</h4>
                <p>Connection: <span id="connectionStatusFooter">üî¥ CONNECTING...</span></p>
                <p>RPC Health: <span id="rpcHealth" class="positive">HEALTHY</span></p>
                <p>Token Tracking: <span id="trackingStatus" class="positive">ACTIVE</span></p>
                <p>SOL Rate: <span id="solRate">‚Ç¨147.79/SOL</span></p>
                <p>Tokens Detected: <span id="tokensDetected" class="positive">0</span></p>
                <p>Detection Rate: <span id="detectionRate">0/min</span></p>
            </div>
            
            <div class="footer-section">
                <h4>‚ö†Ô∏è Important Notice</h4>
                <p>This is an educational simulation tool</p>
                <p>All trades are simulated with virtual funds</p>
                <p>No real money is used or at risk</p>
                <p>Designed for learning blockchain concepts</p>
            </div>
            
            <div class="footer-section">
                <h4>üîç Data Sources</h4>
                <p>Live Prices: <span class="positive">DexScreener API</span></p>
                <p>Liquidity Data: <span class="positive">REAL</span></p>
                <p>Market Movements: <span class="positive">ACTUAL</span></p>
                <p>Trading Activity: <span class="negative">SIMULATED</span></p>
            </div>
        </div>
        
        <div style="text-align: center; border-top: 1px solid #333; padding-top: 1rem;">
            SOLANA SNIPER BOT v2.0 | EDUCATIONAL SIMULATION MODE | NO REAL TRADING
        </div>
    </div>

    <script>
        const socket = io();
        let isConnected = false;

        // KPI Chart Management
        let kpiChart = null;
        let currentChartType = 'portfolio';
        let kpiData = {
            portfolio: [],
            detection: [],
            trading: [],
            liquidity: []
        };

        // Initialize global data structures
        window.foundTokensData = [];
        window.trackedTokensData = [];
        window.migrationData = [];
        window.kpiData = {};
        window.lastTokenUpdate = Date.now();
        
        // Initialize detection stats for better logging
        window.detectionStats = {
            totalDetected: 0,
            lastDetection: 0,
            sources: {},
            slowDetections: 0,
            lastLogTime: 0 // Prevent log spam
        };

        // Connection status
        socket.on('connect', () => {
            isConnected = true;
            document.getElementById('connectionStatus').innerHTML = 'üü¢ CONNECTED';
            document.getElementById('connectionStatusFooter').innerHTML = 'üü¢ CONNECTED';
            console.log('Connected to dashboard');
        });

        socket.on('disconnect', () => {
            isConnected = false;
            document.getElementById('connectionStatus').innerHTML = 'üî¥ DISCONNECTED';
            document.getElementById('connectionStatusFooter').innerHTML = 'üî¥ DISCONNECTED';
        });

        // Portfolio updates
        socket.on('portfolio', (stats) => {
            updatePortfolioStats(stats);
        });

        // Position updates
        socket.on('positions', (positions) => {
            updatePositionsGrid(positions);
        });

        // New trades
        socket.on('newTrade', (trade) => {
            addTradeToFeed(trade);
            
            // Update analyzed tokens data with trade action
            if (window.analyzedTokensData) {
                const tokenIndex = window.analyzedTokensData.findIndex(t => t.id === trade.mint);
                if (tokenIndex !== -1) {
                    window.analyzedTokensData[tokenIndex].action = trade.type;
                    window.analyzedTokensData[tokenIndex].reason = trade.reason;
                    updateAnalyzedTokensTable(window.analyzedTokensData);
                }
            }
        });

        // Initial trades data
        socket.on('recentTrades', (trades) => {
            if (trades && trades.length > 0) {
                const feed = document.getElementById('tradeFeed');
                feed.innerHTML = ''; // Clear waiting message
                trades.forEach(trade => addTradeToFeed(trade));
            }
        });

        // KPI updates
        socket.on('kpiUpdate', (data) => {
            updateKPIChart(data);
        });

        // Tracked tokens updates
        socket.on('trackedTokens', (tokens) => {
            updateTrackedTokensTable(tokens);
        });

        // Token tracking events
        socket.on('tokenAdded', (token) => {
            console.log('Token added to tracking:', token.symbol);
            updateTrackedTokensCount();
            
            // Add to tracked tokens data
            if (window.trackedTokensData) {
                window.trackedTokensData.unshift(token);
                // Keep only last 100 tokens
                if (window.trackedTokensData.length > 100) {
                    window.trackedTokensData = window.trackedTokensData.slice(0, 100);
                }
                updateTrackedTokensTable(window.trackedTokensData);
            }
        });
        
        // New token events
        socket.on('newTokensFound', (tokens) => {
            if (tokens && tokens.length > 0) {
                console.log(`New tokens found: ${tokens.length}`);
                // Add to found tokens data
                tokens.forEach(token => {
                    if (window.foundTokensData) {
                        const tokenData = {
                            id: token.mint,
                            symbol: token.symbol || 'UNK',
                            name: token.name || 'Unknown',
                            price: 0, // Will be updated by price tracking
                            foundAt: Date.now(),
                            createdAt: token.createdAt || Date.now(),
                            liquidity: token.liquidity?.usd || 0,
                            dexId: token.source,
                            isPump: token.source === 'pump_detector'
                        };
                        window.foundTokensData.unshift(tokenData);
                        // Keep only last 50 tokens
                        if (window.foundTokensData.length > 50) {
                            window.foundTokensData = window.foundTokensData.slice(0, 50);
                        }
                    }
                });
                updateFoundTokensTable(window.foundTokensData);
            }
        });

        // New token detection events from detector
        socket.on('newTokensDetected', (tokens) => {
            if (tokens && tokens.length > 0) {
                console.log(`üéØ New tokens detected: ${tokens.length}`);
                // Add to found tokens data
                tokens.forEach(token => {
                    if (window.foundTokensData) {
                        const tokenData = {
                            id: token.mint,
                            symbol: token.symbol || 'UNK',
                            name: token.name || 'Unknown',
                            price: token.metadata?.priceUsd || 0,
                            foundAt: Date.now(),
                            createdAt: token.timestamp || Date.now(),
                            liquidity: token.liquidity?.usd || 0,
                            dexId: token.source,
                            isPump: token.source?.includes('pump') || false
                        };
                        window.foundTokensData.unshift(tokenData);
                        // Keep only last 50 tokens
                        if (window.foundTokensData.length > 50) {
                            window.foundTokensData = window.foundTokensData.slice(0, 50);
                        }
                    }
                });
                updateFoundTokensTable(window.foundTokensData);
            }
        });

        // Found tokens events from dashboard
        socket.on('foundTokens', (tokens) => {
            if (tokens && tokens.length > 0) {
                console.log(`üì° Found tokens updated: ${tokens.length}`);
                // Update found tokens data
                if (window.foundTokensData) {
                    tokens.forEach(token => {
                        // Check if token already exists
                        const existingIndex = window.foundTokensData.findIndex(t => t.id === token.mint);
                        if (existingIndex === -1) {
                            window.foundTokensData.unshift(token);
                        } else {
                            // Update existing token
                            window.foundTokensData[existingIndex] = { ...window.foundTokensData[existingIndex], ...token };
                        }
                    });
                    // Keep only last 50 tokens
                    if (window.foundTokensData.length > 50) {
                        window.foundTokensData = window.foundTokensData.slice(0, 50);
                    }
                    updateFoundTokensTable(window.foundTokensData);
                }
            }
        });

        // Detection result events - optimized logging with spam prevention
        socket.on('detectionResult', (result) => {
            const tokenCount = result.detectedCount || 0;
            const source = result.source || 'unknown';
            const processingTime = result.processingTime || 0;
            const now = Date.now();
            
            // Update detection stats
            if (window.detectionStats) {
                window.detectionStats.totalDetected += tokenCount;
                window.detectionStats.sources[source] = (window.detectionStats.sources[source] || 0) + tokenCount;
                
                if (tokenCount > 0) {
                    window.detectionStats.lastDetection = now;
                }
                
                if (processingTime > 1000) {
                    window.detectionStats.slowDetections++;
                }
            }
            
            // Throttled logging - only log every 10 seconds for zero results, always log when tokens found
            const shouldLog = tokenCount > 0 || 
                            processingTime > 1000 || 
                            (now - (window.detectionStats.lastLogTime || 0)) > 10000;
                            
            if (shouldLog) {
                if (tokenCount > 0) {
                    console.log(`üìä Detection: ${tokenCount} tokens from ${source} (${processingTime}ms)`);
                } else if (processingTime > 1000) {
                    console.log(`‚ö†Ô∏è Slow detection: ${source} took ${processingTime}ms`);
                } else {
                    console.log(`üìä Detection scan: ${source} (${processingTime}ms) - no tokens found`);
                }
                
                if (window.detectionStats) {
                    window.detectionStats.lastLogTime = now;
                }
            }
            
            // Update detection stats display
            updateDetectionStatsDisplay();
        });

        socket.on('priceUpdate', (data) => {
            console.log('Price update:', data.token.symbol, data.newPrice);
            updateTrackedTokensTable();
        });

        socket.on('significantPriceChange', (data) => {
            console.log('Significant price change:', data.token.symbol, data.changePercent + '%');
            // Could show notification here
        });

        function updatePortfolioStats(stats) {
            // Main portfolio value
            const totalValueElement = document.getElementById('totalValue');
            totalValueElement.textContent = stats.totalPortfolioValue.toFixed(4) + ' SOL';
            totalValueElement.className = 'mini-info-value ' + (stats.totalROI >= 0 ? 'positive' : 'negative');
            
            document.getElementById('totalValueEur').textContent = '‚Ç¨' + (stats.totalPortfolioValueEur || 0).toFixed(2);
            
            // Available balance
            const availableBalanceElement = document.getElementById('availableBalance');
            availableBalanceElement.textContent = stats.currentBalance.toFixed(4) + ' SOL';
            availableBalanceElement.className = 'mini-info-value neutral';
            
            document.getElementById('availableBalanceEur').textContent = '‚Ç¨' + (stats.currentBalanceEur || 0).toFixed(2);
            
            // Total ROI
            const roiElement = document.getElementById('totalROI');
            roiElement.textContent = (stats.totalROI >= 0 ? '+' : '') + stats.totalROI.toFixed(2) + '%';
            roiElement.className = 'mini-info-value ' + (stats.totalROI >= 0 ? 'positive' : 'negative');

            // Win rate
            const winRateElement = document.getElementById('winRate');
            winRateElement.textContent = (stats.winRate || 0).toFixed(1) + '%';
            winRateElement.className = 'mini-info-value ' + (stats.winRate >= 50 ? 'positive' : stats.winRate >= 25 ? 'neutral' : 'negative');
            
            // Win rate detail
            const winRateDetailElement = document.getElementById('winRateDetail');
            winRateDetailElement.textContent = `${stats.winningTrades || 0}/${stats.totalTrades || 0} trades`;
            
            // Active positions
            const activePositionsElement = document.getElementById('activePositions');
            activePositionsElement.textContent = stats.activePositions || 0;
            activePositionsElement.className = 'mini-info-value ' + (stats.activePositions > 0 ? 'positive' : 'neutral');

            // Update footer info
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            
            // Update KPI data with proper values
            addKPIDataPoint('portfolio', stats.totalPortfolioValue || 0);
            addKPIDataPoint('trading', stats.totalTrades || 0);
            
            // Also update other chart data if available
            const foundTokensCount = window.foundTokensData ? window.foundTokensData.length : 0;
            const analyzedTokensCount = window.analyzedTokensData ? window.analyzedTokensData.length : 0;
            
            addKPIDataPoint('detection', foundTokensCount);
            
            // Calculate average liquidity for liquidity chart
            if (window.trackedTokensData && window.trackedTokensData.length > 0) {
                const avgLiquidity = window.trackedTokensData.reduce((sum, token) => sum + (token.liquidityUsd || 0), 0) / window.trackedTokensData.length;
                addKPIDataPoint('liquidity', avgLiquidity / 1000); // Scale down for chart
            }
        }

        function updatePositionsGrid(positions) {
            const grid = document.getElementById('positionsGrid');
            const noPositions = document.getElementById('noPositions');
            
            if (positions.length === 0) {
                noPositions.style.display = 'block';
                // Clear any existing position cards
                const existingCards = grid.querySelectorAll('.position-card');
                existingCards.forEach(card => card.remove());
            } else {
                noPositions.style.display = 'none';
                
                // Clear existing cards
                const existingCards = grid.querySelectorAll('.position-card');
                existingCards.forEach(card => card.remove());
                
                // Create new position cards
                positions.forEach(position => {
                    const card = createPositionCard(position);
                    grid.appendChild(card);
                });
            }
        }

        function createPositionCard(position) {
            const card = document.createElement('div');
            card.className = 'position-card';
            
            const duration = Math.floor((Date.now() - position.entryTime) / 1000);
            const durationText = formatDuration(duration);
            const roi = position.roi || 0;
            const roiClass = roi >= 0 ? 'positive' : 'negative';
            
            // Add special effects based on ROI
            if (roi > 100) {
                card.classList.add('glowing');
                card.style.borderColor = '#ff6600';
            } else if (roi > 50) {
                card.classList.add('glowing');
            } else if (roi < -15) {
                card.style.borderColor = '#ff0066';
            }
            
            card.innerHTML = `
                <div class="position-header">
                    <div class="position-token">${position.symbol}</div>
                    <div class="position-status status-${position.status.toLowerCase()}">${position.status}</div>
                </div>
                
                <div class="position-roi ${roiClass}">${roi >= 0 ? '+' : ''}${roi.toFixed(1)}%</div>
                
                <div class="position-details">
                    <div class="position-stat">
                        <div class="position-stat-label">Investment</div>
                        <div class="position-stat-value">${position.simulatedInvestment.toFixed(4)} SOL</div>
                    </div>
                    
                    <div class="position-stat">
                        <div class="position-stat-label">Current Value</div>
                        <div class="position-stat-value ${roiClass}">${(position.simulatedInvestment * (1 + roi / 100)).toFixed(4)} SOL</div>
                    </div>
                    
                    <div class="position-stat">
                        <div class="position-stat-label">Duration</div>
                        <div class="position-stat-value">${durationText}</div>
                    </div>
                    
                    <div class="position-stat">
                        <div class="position-stat-label">P&L</div>
                        <div class="position-stat-value ${roiClass}">${roi >= 0 ? '+' : ''}${(position.simulatedInvestment * roi / 100).toFixed(4)} SOL</div>
                    </div>
                </div>
            `;
            
            return card;
        }

        function formatDuration(seconds) {
            if (seconds < 60) return `${seconds}s`;
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes}m`;
            const hours = Math.floor(minutes / 60);
            const remainingMinutes = minutes % 60;
            return `${hours}h ${remainingMinutes}m`;
        }

        function addTradeToFeed(trade) {
            const feed = document.getElementById('tradeFeed');
            
            // Clear "waiting" message if present
            if (feed.children.length === 1 && feed.children[0].textContent.includes('Waiting')) {
                feed.innerHTML = '';
            }
            
            const tradeElement = document.createElement('div');
            tradeElement.className = `trade-item trade-${trade.type.toLowerCase()}`;
            
            const time = new Date(trade.timestamp).toLocaleTimeString();
            const typeIcon = trade.type === 'BUY' ? 'üöÄ' : 'üí∞';
            const typeColor = trade.type === 'BUY' ? '#00ff88' : '#ff0066';
            
            tradeElement.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <div style="color: ${typeColor}; font-weight: 600; font-size: 0.9rem;">
                            ${typeIcon} ${trade.type} ${trade.symbol}
                        </div>
                        <div style="color: #999; font-size: 0.8rem; margin-top: 0.25rem;">
                            ${trade.reason || 'Automated trade'}
                        </div>
                    </div>
                    <div style="text-align: right;">
                        <div style="font-weight: 600; color: #fff;">
                            ${trade.amount.toFixed(4)} SOL
                        </div>
                        <div style="color: #666; font-size: 0.8rem; margin-top: 0.25rem;">
                            ${time}
                        </div>
                    </div>
                </div>
            `;
            
            feed.insertBefore(tradeElement, feed.firstChild);
            
            // Keep only last 15 trades
            while (feed.children.length > 15) {
                feed.removeChild(feed.lastChild);
            }
        }

        function updateTokenStats(stats) {
            document.getElementById('tokensFound').textContent = stats.found || 0;
            document.getElementById('tokensAnalyzed').textContent = stats.analyzed || 0;
            
            // Count pump signals from pump detection stats
            const pumpCount = stats.pumpDetection?.trackedTokens || 0;
            document.getElementById('pumpSignals').textContent = pumpCount;
        }

        function updateFoundTokensTable(tokens) {
            const tbody = document.querySelector('#foundTokensTable tbody');
            const noTokens = document.getElementById('noFoundTokens');
            
            if (!tokens || tokens.length === 0) {
                tbody.innerHTML = '';
                noTokens.style.display = 'block';
                return;
            }
            
            noTokens.style.display = 'none';
            tbody.innerHTML = '';
            
            tokens.slice(0, 10).forEach(token => {
                // Calculate real-time token age from creation timestamp
                const ageMs = Date.now() - (token.foundAt || token.createdAt || Date.now());
                const ageText = formatDuration(Math.floor(ageMs / 1000));
                
                const pumpBadge = token.isPump ? ' üö®' : '';
                const priceText = formatPrice(token.price);
                
                // Format liquidity
                const liquidityText = token.liquidity > 0 ? formatCurrency(token.liquidity) : '-';
                
                // Security score with color
                const securityScore = token.securityScore || Math.floor(Math.random() * 40) + 50;
                const securityColor = securityScore >= 80 ? '#00ff88' : securityScore >= 60 ? '#ffaa00' : '#ff0066';
                
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
                row.innerHTML = `
                    <td style="padding: 0.5rem;">
                        <strong>${token.symbol}${pumpBadge}</strong>
                        <br><small style="color: #ccc;">${token.name || 'Unknown'}</small>
                    </td>
                    <td style="padding: 0.5rem; text-align: right; color: #fff;">${priceText}</td>
                    <td style="padding: 0.5rem; text-align: right; color: ${securityColor};">${securityScore}/100</td>
                    <td style="padding: 0.5rem; text-align: right;">${liquidityText}</td>
                    <td style="padding: 0.5rem; text-align: right; color: #00ff88;">${ageText}</td>
                    <td style="padding: 0.5rem; text-align: center;">
                        <span style="background: rgba(0,136,255,0.2); color: #0088ff; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">
                            ${token.dexId || token.source || 'UNK'}
                        </span>
                    </td>
                `;
                tbody.appendChild(row);
            });
        }

        function updateAnalyzedTokensTable(tokens) {
            const tbody = document.querySelector('#analyzedTokensTable tbody');
            const noTokens = document.getElementById('noAnalyzedTokens');
            
            if (!tokens || tokens.length === 0) {
                tbody.innerHTML = '';
                noTokens.style.display = 'block';
                return;
            }
            
            noTokens.style.display = 'none';
            tbody.innerHTML = '';
            
            tokens.slice(0, 15).forEach(token => {
                // Calculate real-time token age
                const ageMs = Date.now() - (token.analyzedAt || token.createdAt || Date.now());
                const ageText = formatDuration(Math.floor(ageMs / 1000));
                
                const pumpBadge = token.isPump ? ' üö®' : '';
                const priceText = formatPrice(token.price);
                const scoreColor = token.securityScore >= 70 ? '#00ff88' : token.securityScore >= 50 ? '#ffaa00' : '#ff0066';
                const actionColor = getActionColor(token.action);
                
                // Status indicator with live updates
                let statusIndicator = '';
                if (token.action === 'BUY' || token.action === 'PUMP') {
                    statusIndicator = '‚úÖ POSITION TAKEN';
                } else if (token.action === 'SKIP' || token.action === 'SKIP_HONEYPOT') {
                    statusIndicator = '‚ùå SKIPPED';
                } else {
                    statusIndicator = 'üîç ANALYZING';
                }
                
                const row = document.createElement('tr');
                row.style.borderBottom = '1px solid rgba(255,255,255,0.1)';
                row.innerHTML = `
                    <td style="padding: 0.5rem;">
                        <strong>${token.symbol}${pumpBadge}</strong>
                        <br><small style="color: #ccc;">${token.name || 'Unknown'}</small>
                        <br><small style="color: #888; font-size: 0.7rem;">${statusIndicator}</small>
                    </td>
                    <td style="padding: 0.5rem; text-align: right; color: #fff;">${priceText}</td>
                    <td style="padding: 0.5rem; text-align: right;">
                        <span style="color: ${scoreColor}; font-weight: bold;">${token.securityScore || 0}</span>
                    </td>
                    <td style="padding: 0.5rem; text-align: center;">
                        <span style="background: ${actionColor}; color: #fff; padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.8rem;">
                            ${token.action || 'PENDING'}
                        </span>
                    </td>
                    <td style="padding: 0.5rem; text-align: right; color: #00ff88;">${ageText}</td>
                `;
                tbody.appendChild(row);
            });
        }

        function formatAge(ageMinutes) {
            if (ageMinutes < 1) return '<1m';
            if (ageMinutes < 60) return `${Math.floor(ageMinutes)}m`;
            const hours = Math.floor(ageMinutes / 60);
            const mins = Math.floor(ageMinutes % 60);
            return `${hours}h${mins > 0 ? mins + 'm' : ''}`;
        }
        
        function formatCurrency(amount) {
            if (amount >= 1000000) return '$' + (amount / 1000000).toFixed(1) + 'M';
            if (amount >= 1000) return '$' + (amount / 1000).toFixed(1) + 'K';
            return '$' + (amount || 0).toFixed(0);
        }

        function formatPrice(price) {
            if (!price || price <= 0) return '-';
            
            // For very small prices (less than 0.001), use scientific notation
            if (price < 0.000001) {
                return '$' + price.toExponential(2);
            }
            // For small prices (less than 0.01), show 6 decimal places
            else if (price < 0.01) {
                return '$' + price.toFixed(6);
            }
            // For medium prices (less than 1), show 4 decimal places
            else if (price < 1) {
                return '$' + price.toFixed(4);
            }
            // For larger prices, show 2 decimal places
            else {
                return '$' + price.toFixed(2);
            }
        }

        function getActionColor(action) {
            switch(action) {
                case 'BUY':
                case 'PUMP': return 'rgba(0, 255, 136, 0.8)';
                case 'PROCESSING': return 'rgba(255, 170, 0, 0.8)';
                case 'DETECTED': return 'rgba(0, 136, 255, 0.8)';
                case 'ANALYZED': return 'rgba(136, 136, 255, 0.8)';
                case 'SKIP':
                case 'SKIP_HONEYPOT': 
                case 'ERROR': return 'rgba(255, 0, 102, 0.8)';
                default: return 'rgba(158, 158, 158, 0.6)';
            }
        }

        // Fetch token data
        function fetchTokenData() {
            fetch('/api/tokens/stats')
                .then(response => response.json())
                .then(updateTokenStats)
                .catch(console.error);
                
            fetch('/api/tokens/found')
                .then(response => response.json())
                .then(updateFoundTokensTable)
                .catch(console.error);
                
            fetch('/api/tokens/analyzed')
                .then(response => response.json())
                .then(updateAnalyzedTokensTable)
                .catch(console.error);
        }

        // Request initial data
        if (isConnected) {
            socket.emit('requestPortfolio');
            socket.emit('requestPositions');
            fetchTokenData();
            fetchInitialTrades();
        }

        // Fetch initial trades
        function fetchInitialTrades() {
            fetch('/api/trades')
                .then(response => response.json())
                .then(trades => {
                    if (trades && trades.length > 0) {
                        const feed = document.getElementById('tradeFeed');
                        feed.innerHTML = ''; // Clear waiting message
                        trades.forEach(trade => addTradeToFeed(trade));
                    }
                })
                .catch(console.error);
        }

        // Periodic updates - more frequent for live data
        setInterval(() => {
            if (isConnected) {
                socket.emit('requestPortfolio');
                socket.emit('requestPositions');
                socket.emit('requestTokenData');
                fetchTokenData();
                
                // Update real-time ages for all tokens
                if (window.foundTokensData && window.foundTokensData.length > 0) {
                    updateFoundTokensTable(window.foundTokensData);
                }
                if (window.analyzedTokensData && window.analyzedTokensData.length > 0) {
                    updateAnalyzedTokensTable(window.analyzedTokensData);
                }
                if (window.trackedTokensData && window.trackedTokensData.length > 0) {
                    updateTrackedTokensTable(window.trackedTokensData);
                }
            }
        }, 3000); // Update every 3 seconds for optimal performance

        // RPC Iframe Communication
        class RPCIframeManager {
            constructor() {
                this.iframe = null;
                this.isReady = false;
                this.pendingRequests = new Map();
                this.initializeIframe();
                this.setupMessageListener();
            }

            initializeIframe() {
                this.iframe = document.createElement('iframe');
                this.iframe.src = '/rpc-iframe.html';
                this.iframe.style.display = 'none';
                this.iframe.style.width = '0';
                this.iframe.style.height = '0';
                document.body.appendChild(this.iframe);
            }

            setupMessageListener() {
                window.addEventListener('message', (event) => {
                    if (event.origin !== window.location.origin) return;
                    
                    switch (event.data.type) {
                        case 'RPC_IFRAME_READY':
                            this.isReady = true;
                            console.log('üöÄ RPC Iframe ready');
                            break;
                        
                        case 'RPC_RESPONSE':
                            this.handleRPCResponse(event.data);
                            break;
                        
                        case 'RPC_ERROR':
                            this.handleRPCError(event.data);
                            break;
                        
                        case 'RPC_HEALTH_CHECK':
                            this.handleHealthCheck(event.data);
                            break;
                        
                        case 'RPC_INITIAL_TEST':
                            this.handleInitialTest(event.data);
                            break;
                    }
                });
            }

            async sendRPCRequest(rpcCall) {
                if (!this.isReady) {
                    throw new Error('RPC iframe not ready');
                }

                const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                
                return new Promise((resolve, reject) => {
                    this.pendingRequests.set(requestId, { resolve, reject });
                    
                    this.iframe.contentWindow.postMessage({
                        type: 'RPC_REQUEST',
                        payload: { rpcCall, requestId }
                    }, window.location.origin);
                    
                    // 30 second timeout
                    setTimeout(() => {
                        if (this.pendingRequests.has(requestId)) {
                            this.pendingRequests.delete(requestId);
                            reject(new Error('RPC request timeout'));
                        }
                    }, 30000);
                });
            }

            handleRPCResponse(data) {
                const { requestId, payload } = data;
                const request = this.pendingRequests.get(requestId);
                
                if (request) {
                    this.pendingRequests.delete(requestId);
                    request.resolve(payload);
                    
                    // Send to backend
                    this.sendRPCDataToBackend(payload);
                }
            }

            handleRPCError(data) {
                const { requestId, error } = data;
                const request = this.pendingRequests.get(requestId);
                
                if (request) {
                    this.pendingRequests.delete(requestId);
                    request.reject(new Error(error));
                }
            }

            handleHealthCheck(data) {
                const statusText = data.healthy ? 'RPC: üü¢ Healthy' : 'RPC: üî¥ Unhealthy';
                console.log(statusText);
                
                // Update UI if needed
                const rpcStatus = document.getElementById('rpcStatus');
                if (rpcStatus) {
                    rpcStatus.textContent = statusText;
                }
            }

            handleInitialTest(data) {
                if (data.success) {
                    console.log('‚úÖ RPC connection test successful');
                    this.sendRPCDataToBackend(data.result);
                } else {
                    console.error('‚ùå RPC connection test failed:', data.error);
                }
            }

            async sendRPCDataToBackend(rpcData) {
                try {
                    await fetch('/api/rpc-data', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(rpcData)
                    });
                } catch (error) {
                    console.error('Failed to send RPC data to backend:', error);
                }
            }

            // Helper methods
            async getLatestBlockhash(commitment = 'processed') {
                const rpcCall = {
                    method: 'getLatestBlockhash',
                    jsonrpc: '2.0',
                    params: [{ commitment }],
                    id: Date.now()
                };
                
                return await this.sendRPCRequest(rpcCall);
            }

            async getAccountInfo(address, commitment = 'processed') {
                const rpcCall = {
                    method: 'getAccountInfo',
                    jsonrpc: '2.0',
                    params: [address, { commitment, encoding: 'base64' }],
                    id: Date.now()
                };
                
                return await this.sendRPCRequest(rpcCall);
            }
        }

        // Initialize RPC iframe manager
        const rpcManager = new RPCIframeManager();

        // Test RPC connection periodically
        setInterval(async () => {
            try {
                await rpcManager.getLatestBlockhash();
            } catch (error) {
                console.error('RPC test failed:', error);
            }
        }, 60000); // Test every minute

        // DexScreener Iframe Manager
        class DexScreenerIframeManager {
            constructor() {
                this.iframe = null;
                this.isReady = false;
                this.tokens = [];
                this.initializeIframe();
                this.setupMessageListener();
            }

            initializeIframe() {
                this.iframe = document.createElement('iframe');
                this.iframe.src = '/dexscreener-iframe.html';
                this.iframe.style.display = 'none';
                this.iframe.style.width = '0';
                this.iframe.style.height = '0';
                document.body.appendChild(this.iframe);
            }

            setupMessageListener() {
                window.addEventListener('message', (event) => {
                    if (event.origin !== window.location.origin) return;
                    
                    switch (event.data.type) {
                        case 'DEXSCREENER_READY':
                            this.isReady = true;
                            console.log('üîç DexScreener iframe ready');
                            this.startTokenScraping();
                            break;
                        
                        case 'DEXSCREENER_TOKENS':
                            this.handleTokensReceived(event.data.tokens);
                            break;
                    }
                });
            }

            startTokenScraping() {
                if (!this.isReady) return;
                
                this.iframe.contentWindow.postMessage({
                    type: 'DEXSCREENER_COMMAND',
                    command: 'START_SCRAPING'
                }, window.location.origin);
            }

            stopTokenScraping() {
                if (!this.isReady) return;
                
                this.iframe.contentWindow.postMessage({
                    type: 'DEXSCREENER_COMMAND',
                    command: 'STOP_SCRAPING'
                }, window.location.origin);
            }

            handleTokensReceived(tokens) {
                this.tokens = tokens;
                console.log(`üìä Received ${tokens.length} tokens from DexScreener`);
                
                // Update UI
                this.updateTokenUI();
                
                // Send to backend
                this.sendTokensToBackend(tokens);
            }

            updateTokenUI() {
                // Update token count in UI
                const tokenCountElement = document.getElementById('tokensFound');
                if (tokenCountElement) {
                    tokenCountElement.textContent = this.tokens.length;
                }

                // Update last token info
                const lastTokenElement = document.getElementById('lastToken');
                if (lastTokenElement && this.tokens.length > 0) {
                    const latestToken = this.tokens[this.tokens.length - 1];
                    lastTokenElement.textContent = `${latestToken.symbol} (${latestToken.age}s old)`;
                }

                // Update found tokens table
                this.updateFoundTokensTable();
            }

            updateFoundTokensTable() {
                const tableBody = document.querySelector('#foundTokensTable tbody');
                const noTokensDiv = document.getElementById('noFoundTokens');
                
                if (!tableBody) return;
                
                tableBody.innerHTML = '';
                
                if (this.tokens.length === 0) {
                    if (noTokensDiv) noTokensDiv.style.display = 'block';
                    return;
                }
                
                if (noTokensDiv) noTokensDiv.style.display = 'none';
                
                // Show latest 10 tokens
                const recentTokens = this.tokens.slice(-10).reverse();
                
                recentTokens.forEach(token => {
                    const row = document.createElement('tr');
                    
                    // Format liquidity
                    // Using global formatCurrency function
                    
                    // Mock security score (would come from analysis)
                    const securityScore = Math.floor(Math.random() * 50) + 50; // 50-100
                    const securityColor = securityScore >= 80 ? '#00ff88' : securityScore >= 60 ? '#ffaa00' : '#ff0066';
                    
                    row.innerHTML = `
                        <td style="padding: 0.5rem; font-weight: bold;">${token.symbol}</td>
                        <td style="padding: 0.5rem; text-align: right;">${formatPrice(token.price)}</td>
                        <td style="padding: 0.5rem; text-align: right; color: ${securityColor};">${securityScore}/100</td>
                        <td style="padding: 0.5rem; text-align: right;">${formatCurrency(token.liquidity)}</td>
                        <td style="padding: 0.5rem; text-align: right;">${token.age}s</td>
                        <td style="padding: 0.5rem; text-align: center;"><span style="background: rgba(0,136,255,0.2); color: #0088ff; padding: 0.2rem 0.4rem; border-radius: 4px; font-size: 0.7rem;">${token.source}</span></td>
                    `;
                    tableBody.appendChild(row);
                });
            }

            async sendTokensToBackend(tokens) {
                try {
                    const response = await fetch('/api/dexscreener-tokens', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ tokens, timestamp: Date.now() })
                    });
                    
                    if (response.ok) {
                        console.log('‚úÖ Tokens sent to backend successfully');
                    } else {
                        console.error('‚ùå Failed to send tokens to backend:', response.status);
                    }
                } catch (error) {
                    console.error('‚ùå Error sending tokens to backend:', error);
                }
            }

            getTokens() {
                return this.tokens;
            }
        }

        // Initialize DexScreener iframe manager
        const dexScreenerManager = new DexScreenerIframeManager();

        // KPI Chart Functions
        function initializeKPIChart() {
            const ctx = document.getElementById('kpiChart').getContext('2d');
            kpiChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Portfolio Value',
                        data: [],
                        borderColor: '#00ff88',
                        backgroundColor: 'rgba(0, 255, 136, 0.1)',
                        tension: 0.4,
                        fill: true,
                        pointRadius: 2,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 500 // Smooth but quick animations
                    },
                    interaction: {
                        intersect: false,
                        mode: 'index'
                    },
                    scales: {
                        x: {
                            ticks: { 
                                color: '#fff',
                                maxTicksLimit: 10 // Limit x-axis labels
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        },
                        y: {
                            ticks: { 
                                color: '#fff',
                                callback: function(value) {
                                    if (currentChartType === 'portfolio') {
                                        return value.toFixed(3) + ' SOL';
                                    }
                                    return value;
                                }
                            },
                            grid: { color: 'rgba(255, 255, 255, 0.1)' }
                        }
                    },
                    plugins: {
                        legend: {
                            labels: { color: '#fff' }
                        },
                        tooltip: {
                            titleColor: '#fff',
                            bodyColor: '#fff',
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            borderColor: '#00ff88',
                            borderWidth: 1
                        }
                    }
                }
            });
        }

        function addKPIDataPoint(type, value) {
            const timestamp = new Date().toLocaleTimeString();
            
            if (!kpiData[type]) {
                kpiData[type] = [];
            }
            
            // Only add if value has changed significantly or enough time has passed
            const lastEntry = kpiData[type][kpiData[type].length - 1];
            const now = Date.now();
            const minInterval = 10000; // 10 seconds minimum between updates
            
            if (!lastEntry || 
                now - lastEntry.time > minInterval || 
                Math.abs(value - lastEntry.value) > (lastEntry.value * 0.01)) { // 1% change threshold
                
                kpiData[type].push({
                    timestamp,
                    value: parseFloat(value) || 0,
                    time: now
                });
                
                // Keep only last 30 data points for better history
                if (kpiData[type].length > 30) {
                    kpiData[type] = kpiData[type].slice(-30);
                }
                
                // Update chart if it's the current type
                if (type === currentChartType) {
                    updateKPIChart();
                }
            }
        }

        function updateKPIChart(data) {
            if (!kpiChart) return;
            
            const chartData = kpiData[currentChartType] || [];
            
            kpiChart.data.labels = chartData.map(d => d.timestamp);
            kpiChart.data.datasets[0].data = chartData.map(d => d.value);
            kpiChart.update();
        }

        function switchChart(type) {
            currentChartType = type;
            
            // Update active tab
            document.querySelectorAll('.chart-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelector(`[data-chart="${type}"]`).classList.add('active');
            
            // Update chart
            const chartConfigs = {
                portfolio: {
                    label: 'Portfolio Value (SOL)',
                    color: '#00ff88'
                },
                detection: {
                    label: 'Tokens Detected',
                    color: '#0088ff'
                },
                trading: {
                    label: 'Total Trades',
                    color: '#ff6600'
                },
                liquidity: {
                    label: 'Avg Liquidity (USD)',
                    color: '#ff0066'
                }
            };
            
            const config = chartConfigs[type];
            kpiChart.data.datasets[0].label = config.label;
            kpiChart.data.datasets[0].borderColor = config.color;
            kpiChart.data.datasets[0].backgroundColor = config.color + '20';
            
            updateKPIChart();
        }

        // Chart tab click handlers
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.chart-tab').forEach(tab => {
                tab.addEventListener('click', (e) => {
                    const chartType = e.target.dataset.chart;
                    switchChart(chartType);
                });
            });
            
            // Initialize chart
            initializeKPIChart();
        });

        // Tracked Tokens Functions
        function updateTrackedTokensTable(tokens) {
            const tbody = document.querySelector('#trackedTokensTable tbody');
            const noTokens = document.getElementById('noTrackedTokens');
            
            if (!tokens || tokens.length === 0) {
                tbody.innerHTML = '';
                noTokens.style.display = 'block';
                document.getElementById('trackedTokensTable').style.display = 'none';
                return;
            }
            
            noTokens.style.display = 'none';
            document.getElementById('trackedTokensTable').style.display = 'table';
            tbody.innerHTML = '';
            
            // Get current positions for buy/sell tracking
            const positions = window.currentPositions || [];
            
            tokens.forEach(token => {
                const row = document.createElement('tr');
                const priceChange = token.priceChange24h || 0;
                const changeClass = priceChange >= 0 ? 'positive' : 'negative';
                const changeText = (priceChange >= 0 ? '+' : '') + priceChange.toFixed(2) + '%';
                
                const age = Math.floor((Date.now() - token.detectedAt) / 60000);
                const ageText = age < 60 ? age + 'm' : Math.floor(age / 60) + 'h';
                
                // Format volume and liquidity
                // Using global formatCurrency function
                
                const volume = formatCurrency(token.volume24h || 0);
                const liquidity = formatCurrency(token.liquidityUsd || 0);
                
                // Find position data for this token
                const position = positions.find(p => p.mint === token.address || p.symbol === token.symbol);
                let buyAmount = '-';
                let sellAmount = '-';
                let currentROI = '-';
                
                if (position) {
                    buyAmount = position.simulatedInvestment ? position.simulatedInvestment.toFixed(4) + ' SOL' : '-';
                    currentROI = position.roi ? (position.roi >= 0 ? '+' : '') + position.roi.toFixed(2) + '%' : '-';
                    
                    // Check if position was partially or fully sold
                    if (position.status === 'CLOSED') {
                        const exitValue = position.simulatedInvestment * (1 + (position.roi || 0) / 100);
                        sellAmount = exitValue.toFixed(4) + ' SOL';
                    }
                }
                
                // Extract DEX from dexId or set default
                const dex = token.dexId || 'Unknown';
                
                row.innerHTML = `
                    <td><strong>${token.symbol}</strong><br><small style="color: #666;">${token.address ? token.address.slice(0, 6) + '...' + token.address.slice(-4) : 'N/A'}</small></td>
                    <td style="color: #fff;">${formatPrice(token.currentPrice)}</td>
                    <td class="${changeClass}">${changeText}</td>
                    <td>${volume}</td>
                    <td>${liquidity}</td>
                    <td><span class="token-status status-${(token.status || 'tracking').toLowerCase()}">${token.status || 'TRACKING'}</span></td>
                    <td>${ageText}</td>
                    <td><span style="background: rgba(0,136,255,0.2); color: #0088ff; padding: 0.2rem 0.4rem; border-radius: 4px; font-size: 0.7rem;">${dex}</span></td>
                    <td style="color: #00ff88;">${buyAmount}</td>
                    <td style="color: #ff6600;">${sellAmount}</td>
                    <td style="color: ${currentROI.includes('+') ? '#00ff88' : currentROI.includes('-') ? '#ff0066' : '#fff'}; font-weight: bold;">${currentROI}</td>
                `;
                tbody.appendChild(row);
            });
            
            // Update tracked tokens count
            document.getElementById('trackedTokens').textContent = tokens.length;
        }

        function updateTrackedTokensCount() {
            fetch('/api/tracked-tokens/count')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('trackedTokens').textContent = data.count || 0;
                })
                .catch(console.error);
        }

        function updateDetectionStatsDisplay() {
            if (!window.detectionStats) return;
            
            const stats = window.detectionStats;
            const now = Date.now();
            
            // Update total tokens detected
            const tokensDetectedEl = document.getElementById('tokensDetected');
            if (tokensDetectedEl) {
                tokensDetectedEl.textContent = stats.totalDetected;
                tokensDetectedEl.className = stats.totalDetected > 0 ? 'positive' : 'neutral';
            }
            
            // Calculate detection rate (tokens per minute)
            const timeSinceStart = (now - (stats.startTime || now)) / 1000 / 60; // minutes
            const detectionRate = timeSinceStart > 0 ? (stats.totalDetected / timeSinceStart).toFixed(1) : '0.0';
            
            const detectionRateEl = document.getElementById('detectionRate');
            if (detectionRateEl) {
                detectionRateEl.textContent = `${detectionRate}/min`;
            }
            
            // Initialize start time if not set
            if (!stats.startTime) {
                stats.startTime = now;
            }
        }

        // Token stats updates
        function updateTokenStats(stats) {
            document.getElementById('tokensFound').textContent = stats.found || 0;
            document.getElementById('tokensAnalyzed').textContent = stats.analyzed || 0;
            
            // Update KPI data
            addKPIDataPoint('detection', stats.found || 0);
            
            // Count pump signals from pump detection stats
            const pumpCount = stats.pumpDetection?.trackedTokens || 0;
            document.getElementById('pumpSignals').textContent = pumpCount;
        }

        // Add DexScreener controls to UI (for testing)
        document.addEventListener('DOMContentLoaded', () => {
            // Add control buttons (hidden by default)
            const controlsDiv = document.createElement('div');
            controlsDiv.style.position = 'fixed';
            controlsDiv.style.bottom = '20px';
            controlsDiv.style.right = '20px';
            controlsDiv.style.background = 'rgba(0,0,0,0.8)';
            controlsDiv.style.padding = '10px';
            controlsDiv.style.borderRadius = '5px';
            controlsDiv.style.display = 'none'; // Hidden by default
            controlsDiv.id = 'dexscreener-controls';
            
            controlsDiv.innerHTML = `
                <button onclick="dexScreenerManager.startTokenScraping()" style="margin: 5px;">Start Scraping</button>
                <button onclick="dexScreenerManager.stopTokenScraping()" style="margin: 5px;">Stop Scraping</button>
                <button onclick="console.log('Tokens:', dexScreenerManager.getTokens())" style="margin: 5px;">Log Tokens</button>
            `;
            
            document.body.appendChild(controlsDiv);
            
            // Show controls on Ctrl+Shift+D
            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                    const controls = document.getElementById('dexscreener-controls');
                    controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
                }
            });
        });

    </script>
</body>
</html>